---
title: Architecture
description: The eight-layer protocol-first architecture of defuse.
---

## Design Principles

defuse is built on five principles that shape every decision:

- **Terminal-native**: lean into OSC escape sequences, PTY streams, and established terminal conventions — not against them
- **Protocol-first**: every layer boundary is a contract (OSC 133, Maildir, JSON-RPC, SQL) — not a code dependency
- **Modular**: swap any component without touching others; the interface is the architecture
- **Incremental**: each milestone delivers standalone value before the next is started
- **Composable**: connect emerging tools and workflows without rebuilding the platform

## The Eight-Layer Stack

```
┌─────────────────────────────────────────────────────────────────┐
│ L7: TUI Screens                                                 │
│   Ratatui apps in tmux panes                                    │
│   sidebar · dashboard · search · reviews · history              │
├─────────────────────────────────────────────────────────────────┤
│ L6: Shell Integration                                           │
│   carapace completions · starship prompt · reedline/neovim      │
│   shell hooks (precmd/preexec) · CARAPACE_BRIDGES · nvim-cmp    │
├─────────────────────────────────────────────────────────────────┤
│ L5: Quality Gates                                               │
│   AMQ review_request/review_response · cross-model review       │
│   convergence detection · human-in-the-loop escalation          │
│   lint gate (three-phase enforcement, config tamper detection)   │
├─────────────────────────────────────────────────────────────────┤
│ L4: Work Planning + Agent Orchestration                         │
│   shaping-skills (requirements, shapes, breadboards, slices)    │
│   kanban-md (task lifecycle, claims, status, assignment)         │
│   Orchestrator: dfs CLI + daemon (tmux CLI + amq + kanban-md + pi-mono) │
│   jj workspace / git worktree isolation · A/B comparison        │
├─────────────────────────────────────────────────────────────────┤
│ L3: Agent Middleware (pi-mono)                                  │
│   pi-ai unified LLM API (20+ providers + local models)          │
│   RPC mode (JSON/stdio) · extensions · session tree · pi-tui    │
├─────────────────────────────────────────────────────────────────┤
│ L2: Message Bus + Storage                                       │
│   AMQ (Maildir file queue · JSON+MD · priority · threading)     │
│   libSQL (concurrent writers, FTS5/BM25, WAL mode)              │
│   dfs daemon (JSONL + AMQ + kanban-md → libSQL bridge)          │
├─────────────────────────────────────────────────────────────────┤
│ L1: Block Capture                                               │
│   Shell hooks → JSONL → dfs daemon → libSQL                    │
│   Optional tmux capture-pane for output snapshots               │
├─────────────────────────────────────────────────────────────────┤
│ L0: Terminal + Multiplexer                                      │
│   Ghostty renders · tmux manages sessions/panes                 │
│   Both used as-is, not customized                               │
└─────────────────────────────────────────────────────────────────┘
```

## Protocol Contracts

Each layer boundary is a protocol contract. Swapping a component means implementing that contract — nothing else in the stack changes.

| Boundary | Protocol | Current Implementation | Could Swap To |
|---|---|---|---|
| L0 | PTY byte stream + tmux CLI | Ghostty + tmux | Any terminal + any multiplexer |
| L0 → L1 | Shell hook JSONL events | Shell hooks → dfs daemon | Any structured event emitter |
| L1 → L2 | `CommandBlock` JSON objects via SQL inserts | dfs daemon → libSQL | Any SQL database with the schema |
| L2 (AMQ ↔ libSQL) | Daemon watches AMQ Maildir via `notify`, writes projections to libSQL | dfs daemon | Any queue with JSON+MD message format |
| L2 → L3 | `fs.watch()` on inbox + `amq` CLI | AMQ → pi-mono extensions | Unix sockets, Redis streams, custom queue |
| L3 → L4 | pi-mono RPC protocol (JSON over stdio) | pi-mono → Orchestrator CLI | Claude Code SDK, OpenCode ACP, any JSON-RPC agent |
| L4 → L5 | AMQ `review_request`/`review_response` | Orchestrator → review-loop.ts | Any agent speaking AMQ message schema |
| L5 → L6 | Shell environment variables, hook functions | Quality gates → shell | — |
| L6 → L7 | libSQL queries, AMQ status polling, tmux CLI | Shell/data → TUI screens | — |
| Work Planning → L4 | Markdown files with YAML frontmatter in `.shaped/` and `kanban/` | shaping-skills + kanban-md | GitHub Issues + CLI, Linear export, plain TODO.md |
| VCS | `jj workspace create` / `jj diff` / `jj squash` | jj workspaces | git worktrees |
| AI agents | Terminal stdin/stdout + AMQ inbox | Claude Code, OpenCode, Codex CLI, Pi | Any agent that runs in a terminal |

## Swappability

The architecture is defined by the protocols between layers, not the implementations behind them. Every component is independently replaceable:

| Layer | Contract | Current Implementation | Could Swap To |
|---|---|---|---|
| L0: Terminal | Renders PTY output, accepts keyboard input | Ghostty | Any terminal emulator |
| L0: Multiplexer | CLI: `split-window`, `new-window`, `kill-pane`, `list-panes`, `capture-pane`, `select-layout` | tmux | Zellij, custom PTY manager |
| L1: Block Capture | Shell hooks emit JSONL → daemon writes to DB | Shell hooks + dfs daemon | Any structured event pipeline |
| L2: Storage | SQL schema: `command_blocks`, `agent_messages`, `reviews` + FTS5 index | libSQL (WAL mode) | Postgres, plain SQLite |
| L2: Message Bus | `send(msg) → id`, `list(filters) → msgs[]`, `drain() → msgs[]`, `reply(id, msg)` | AMQ (Maildir) | Unix sockets, Redis, custom |
| L3: Agent Runtime | `{type: "prompt", content} → {type: "response", content, tool_calls}` over JSON/stdio | pi-mono RPC | Claude Code SDK, OpenCode ACP |
| L3: Model API | Unified provider abstraction supporting API + local models | pi-ai | Vercel AI SDK, LiteLLM, direct API calls |
| L4: Work Planning | Structured markdown files with YAML frontmatter in `.shaped/` and `kanban/` | shaping-skills + kanban-md | GitHub Issues CLI, Linear, plain TODO.md |
| L7: TUI Screens | Ratatui apps reading libSQL + AMQ + tmux state | Ratatui in tmux panes | Any TUI framework, web UI, native app |

## Key Insight

Warp spent roughly 1,000,000 lines of Rust building a custom GPU renderer, custom UI framework, and custom text editor from scratch. Every one of those components now exists as a mature, composable library or tool. defuse is approximately 5,000 lines of glue connecting approximately 2,000,000 lines of existing, community-maintained tools. The Ratatui TUI screens are the largest single surface area — sidebar, dashboard, search, and review views — because they are the user-facing layer. Everything below is existing tools wired together by protocol.
